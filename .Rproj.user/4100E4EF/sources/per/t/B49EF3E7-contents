---
title: "Hindbrain to Whole Brain Bridging Registrations"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# Bridging registrations

In the course of our work we want to not only be able to register
individual brains to an in-house template, we also want to be
able to register them to external templates such as the ZBB or
Z-brain templates. One problem labs often encounter is that
registering images acquired on one microscope (or from a single
individual) to a template generated from images of another
microscope can lead to poor registration quality. One way to get
around this problem is to register each image to an in-house template
and then create a set of 'bridging' registrations between that 
template and any outside templates. That registration can be used to
align our images with interesting images from other labs, or it can
be used to bring the anatomical label fields from other maps onto our
images.

A second use of bridging registrations is to allow one to register a
sub-region of a brain to a complete whole brain template. For instance,
one might want to acquire high resolution (temporal and/or spatial) scan
of the hindbrain, and then apply the Z-Brain anatomical labels to it.
These two use-cases can be handled in a relatively similar manner.

First, the two templates should be in roughly the same image space as each
other. If one image is rotated in relation to the other, this will
have to be accounted for in the initial registration steps, otherwise
the algorithm might not be able to initialize correctly and all hell
will break loose. If one image has a large displacement from the other in
X, Y, or Z, this will also have to be accounted for, likely by an initial
transformation driven by a seleciton of landmarks.

Next, an affine and warping registration will be applied between the two
templates, initialized by any registration from the above step. This 
registration is what is then used to transform images in their original
space into the target space.

## Initial steps
### Generate Fiji CMTK landmarks
To quickly generate a set of landmarks, we can use a Fiji plug-in
[Name Landmarks and Register](https://imagej.net/Name_Landmarks_and_Register).
This process should only have to be done once per bridging registration,
so the more landmarks chosen, and the more precisely chosen they are, should
only serve to help the initial transformation. One thing I find strange
about the plug-in, is that it will perform rigid and affine transformations,
and then reformat your image into the template space, but it won't obviously 
provide the tranformation matrix. What it will do is allow you to save the
points of both the template and images spaces as CMTK 'formatted' landmark
files. This is a good start, but when I tried using these files directly
in CMTK's *fit_affine_xform_landmarks* the program ran indefinitely without
producing a transformation or an error. This wasn't so useful. Eventaully,
I figured out that I needed to convert the files to a simple matrix, and
that this would work, with a further small modificiation or two.


### Convert Fiji CMTK landmarks
An example of a .landmarks file for the whole brain template
generated by Fiji:

```
! TYPEDSTREAM 1.1
landmark {
	name "caudalMidline"
	location 96.05 285.89 35.0
}
landmark {
	name "leftRostral"
	location 281.36999999999995 218.08999999999997 72.0
}
landmark {
	name "rightRostral"
	location 280.23999999999995 343.52 78.0
}
landmark {
	name "leftRostralCellsMidline"
	location 368.37999999999994 255.37999999999997 25.0
}
landmark {
	name "rightRostralCellsMidline"
	location 368.37999999999994 294.92999999999995 25.0
}
landmark {
	name "leftRostralOlive"
	location 187.57999999999998 245.20999999999998 132.0
}
landmark {
	name "rightRostralOlive"
	location 188.70999999999998 318.65999999999997 132.0
}

```

And the corresponding file for the hind brain template:
```
! TYPEDSTREAM 1.1
landmark {
	name "caudalMidline"
	location 41.34 121.9 42.0
}
landmark {
	name "leftRostral"
	location 229.49 65.19 69.0
}
landmark {
	name "rightRostral"
	location 235.85000000000002 190.27 71.0
}
landmark {
	name "leftRostralCellsMidline"
	location 319.59000000000003 115.54 6.0
}
landmark {
	name "rightRostralCellsMidline"
	location 324.36 151.05 4.0
}
```
Notice that there are two landmarks in the whole brain template
that do not exist in the hind brain template, as well as all of the
text that does not directly specify the x,y,z position of the landmarks.
In order to use these, the extra text and the two extra points need to
be removed. I chose to use R to do this, using the code below.

```{r convertLandmarks functions }
# read a .landmarks file as generated by Fiji's
# landmarks and registration plugin
#
# return a dataframe with a column of names
# and a column of locations
readCMTKFullLandmarks<-function(infile) {
	# read the file
	x=readLines(infile)
	# find the lines with the names of the landmarks
	names<-grep("\tname",x)
	
	# clean up all of the strings
	locations<-x[names+1]
	names<-x[names]
	locations<-sub("\tlocation ", "",locations)
	names<-sub("\tname ","",names)
	
	df<-data.frame(names=names, locations=locations)
	return(df)
}

# read in two CMTK landmark files, merge them
# and write them out to disk

# this is a relatively fragile set of operations
# and can break very easily if every input is not
# as expected
readAndMergeCMTKFullLandmarks<-function(file1,file2){
	l1<-readCMTKFullLandmarks(file1)
	l2<-readCMTKFullLandmarks(file2)
	l12<-merge(l1,l2,by="names")
	if (nrow(l12) < 3) {
		stop("You have fewer than three points for the rigid transformation")
	}
	outfile1 <- sub(".landmarks","-cmtkSimple.landmarks",basename(file1))
	outfile2 <- sub(".landmarks","-cmtkSimple.landmarks",basename(file2))
	cat(as.character(l12$locations.x),file=file.path(dirname(file1),outfile1),sep= "\n")
	cat(as.character(l12$locations.y),file=file.path(dirname(file2),outfile2),sep= "\n")

	invisible(l12)
}
```

```{r scripts for converting landmarks, eval=FALSE}
inDir<-"/F:/Registrations/Claudia/Hind2Full-Bridging"

f1<-file.path(inDir,'images','fish3HindTemplate3correctedDims.landmarks')
f2<-file.path(inDir,'refbrain','fish4WholeTemplate3correctedDims.landmarks')


readAndMergeCMTKFullLandmarks(f1,f2)
```

### Generate a transformation
Now that we have the coordinates we need for a landmarks based
initialization, we can use CMTK's *fit_affine_xform_landmarks*
to generate a transformation.

```{bash, eval=FALSE}
#!/bin/bash


binDir=/opt/local/bin/
regDir=/mnt/f/Registrations/Claudia/Hind2Full-Bridging/
image=fish3HindTemplate3correctedDims-cmtkSimple.landmarks
refbrain=fish4WholeTemplate3correctedDims-cmtkSimple.landmarks
outputXform=fish3HindTemplate3correctedDims-cmtkSimple_fish4WholeTemplate3correctedDims-cmtkSimple.xform

cd ${regDir}

# [options] SourcePath TargetPath OutputXForm
${binDir}/fit_affine_xform_landmarks \
--rigid \
${regDir}/refbrain/$refbrain \
${regDir}/images/$image \
${regDir}/Registration/landmarks/$outputXform

```
We use the `--rigid` flag to let CMTK use our simple landmarks, we specify the source path
as the 'reference' brain (in the case of hindbrain to whole brain registration, the source
has the larger coordinate field that we want to transform into), the target path as our
smaller image being transformed, and we choose an output path.

This gives us a registration transformation that looks something like:

```
! TYPEDSTREAM 2.4

affine_xform {
	xlate -237.544 -157.662 -5 
	rotate -0 -0 -0 
	scale 1 1 1 
	shear 0 0 0 
	center 278.884 279.562 47 
}
```
We can apply this transform to our image:

```{bash, eval=FALSE}
#!/bin/bash

binDir=/opt/local/bin/
regDir=/mnt/f/Registrations/Claudia/Hind2Full-Bridging/
refImage=fish4WholeTemplate3correctedDims.nrrd
floatImage=fish3HindTemplate3correctedDims.nrrd
initXform=fish3HindTemplate3correctedDims-cmtkSimple_fish4WholeTemplate3correctedDims-cmtkSimple.xform

cd ${regDir}

$binDir/reformatx \
--outfile reformatted/landmarksOnly_original.nrrd \
--floating images/$floatImage \
refbrain/$refImage \
Registration/landmarks/$initXform

```

![Landmarks transform without correction](PNGs/hindbrain_after-landmarksXform_uncorrected_merge_crop.png)

If we look at the dimensions of the output image, we see that our hindbrain is now
in the correct space (662x464x315 pixels), but while the image seems to now be
in the correct Y and Z space, it is still off a bit in X. I have no idea why CMTK
outputs an incorrect transformation, but it does. Fortunately, as it does get close in
2 out of 3 dimensions, we can manually edit the transformation matrix and get very close
to the ideal initial transformation:

```
! TYPEDSTREAM 2.4

affine_xform {
	xlate -51.544 -157.662 -5 
	rotate -0 -0 -0 
	scale 1 1 1 
	shear 0 0 0 
	center 278.884 279.562 47 
}
```

We can see this by reformatting our image with this new matrix and see that the two match up
reasonably well:

![Landmarks transform with correction](PNGs/hindbrain_after-landmarksXform_corrected_merge_crop.png)

```{bash, eval=FALSE}
#!/bin/bash

binDir=/opt/local/bin/
regDir=/mnt/f/Registrations/Claudia/Hind2Full-Bridging/
refImage=fish4WholeTemplate3correctedDims.nrrd
floatImage=fish3HindTemplate3correctedDims.nrrd
initXform=fish3HindTemplate3correctedDims-cmtkSimple_fish4WholeTemplate3correctedDims-cmtkSimple.xform
betterXform=hind2whole-manual.xform

cd ${regDir}

$binDir/reformatx \
--outfile reformatted/landmarksOnly_manual.nrrd \
--floating images/$floatImage \
refbrain/$refImage \
Registration/landmarks/$betterXform

```

### Generate our complete registration

Now that we can initialize our partial brain into the space of our
whole brain, we can let CMTK go wild and generate the complete
transformation.

```{bash, eval=FALSE}
#!/bin/bash

binDir=/opt/local/bin/
regDir=/mnt/f/Registrations/Claudia/Hind2Full-Bridging/
refImage=fish4WholeTemplate3correctedDims.nrrd
floatImage=fish3HindTemplate3correctedDims.nrrd
landmarksXform=hind2whole-manual.xform
secondXform=landmarksInitAffine.list/
warpOutPutBridging=HindBrain2WholeBrain_bridging_landmarksWarp.list/

cd ${regDir}

# [options] ReferenceImage [FloatingImage]
$binDir/registrationx \
--omit-original-data \
--init none \
--initial Registration/landmarks/$landmarksXform \
--sampling 2 \
--max-stepsize 26 \
--min-stepsize 8 \
--output Registration/affine/landmarksInitAffine.list/ \
refbrain/${refImage} \
images/$floatImage

# [options] ReferenceImage [FloatingImage] [InitialXform]
$binDir/warp \
--verbose \
--sampling  2 \
--omit-original-data \
--grid-spacing 120 \
--refine 3 \
--accuracy 1.5 \
--energy-weight 0.1 \
--exploration 26 \
--coarsest 8 \
--outlist Registration/warp/$warpOutPut \
refbrain/${refImage} \
images/$floatImage \
Registration/affine/$secondXform

# [options] --floating floatingImage target x0 [x1 ...]
$binDir/reformatx \
--outfile reformatted/HindBrain2WholeBrain_bridging_landmarksWarp.nrrd \
--floating images/$floatImage \
refbrain/$refImage \
Registration/warp/$warpOutPutBridging

```

Finally, we should have our bridging registration in
`Registration/warp/HindBrain2WholeBrain_bridging_landmarksWarp.list/` and we
can get a feel for its accuracy by looking at the reformatted image.

## Using a bridging registration

Now that we (hopefully) have a pretty good bridging registration, we can apply it
to our images.

If we have a raw image that we want to transform, we first need to register it into
the space of our hindbrain template, and then run our final reformatting with both
the unique warp for that image, and the generic bridging warp we have previously 
generated.

```{bash, eval=FALSE}
#!/bin/bash

binDir=/opt/local/bin/
regDir=/mnt/f/Registrations/Claudia/Hind2Full-Bridging/
affineXform=fish3HindTemplate3correctedDims_fish1_correctedDims_01_9dof.list
warpXform=fish3HindTemplate3correctedDims_fish1_correctedDims_01_warp_m0g120c8e1e-1x26r3.list
warpOutPutBridging=HindBrain2WholeBrain_bridging_landmarksWarp.list/
refImageWhole=fish4WholeTemplate3correctedDims.nrrd
refImageHind=fish3HindTemplate3correctedDims.nrrd
floatImage=fish1_correctedDims_01.nrrd
bridgingWarp=bridgingRegistrations/landmarksWarp.list/


cd ${regDir}

# [options] ReferenceImage [FloatingImage]
${binDir}/registration \
-i \
-v \
--dofs 6 ---dofs 9 \
--sampling 2 \
--omit-original-data \
--accuracy 4 \
-o Registration/affine/$affineXform \
refbrain/$refImageHind \
images/$floatImage

# [options] ReferenceImage [FloatingImage] [InitialXform]
${binDir}/warp \
-v \
--registration-metric nmi \
--jacobian-weight 0 \
--fast \
-e 26 \
--grid-spacing 120 \
--energy-weight 1e-1 \
--refine 3 \
--coarsest 8 \
--ic-weight 0 \
--output-intermediate \
--sampling 2 \
--omit-original-data \
--accuracy 1.5 \
-o Registration/warp/$warpXform \
refbrain/$refImageHind \
images/$floatImage \
Registration/affine/$affineXform

# [options] --floating floatingImage target x0 [x1 ...]
$binDir/reformatx \
--outfile reformatted/hindBrain2WholeBrain-bridging_fish1_correctedDims_01.nrrd \
--floating images/$floatImage \
refbrain/$refImageWhole \
Registration/bridging/$warpOutPutBridging \
Registration/warp/$warpXform

```

You will now have the warping registration and the transformed image to look at and use
in any subsequent analysis.

For a more efficient version of this `munger.pl` can be used for the first step of the registration,
and we'll have to work out at some point a simple bash or R script for applying the final reformat.

## Bridging to Z-Brain and ZBB templates

Now that we have a hindbrain template, a whole brain template, and the transformation between the two,
we next will create bridging registrations to the Z-Brain and ZBB templates.

This follows the same process as above, we need to make sure that our template shares a similar enough
space with the two other templates that CMTK can do a reasonable job with its affine registration.
Our template has caudal pointing to the right, and the first slice is dorsal in the brain. This is counter
to ZBB which is caudal left, and ZBrain, which is caudal left and ventral first. To accomodate for this, we
can make an initial transformation that will put our brain in the correct space for each transformation.

ZBB:
```
! TYPEDSTREAM 2.4

affine_xform {
	xlate 748 0 0 
	rotate -0 -0 -0 
	scale -1 1 1 
	shear 0 0 0 
	center 0 0 0 
}
```
Here we use the scale factor to mirror the image across the x-axis, and shift it its full width in x,
bringing it back into the frame. I need to double check if this screws up the chirality of the images;
in that case we can always try to rotate it instead.


ZBrain:
```
! TYPEDSTREAM 2.4

affine_xform {
	xlate 748 0 315 
	rotate -0 -0 -0 
	scale -1 1 -1 
	shear 0 0 0 
	center 0 0 0 
}
```
ZBrain requires a bit more work as it is different in to dimensions, but the process is exactly the same
otherwise.

These two transformations are then used with the `--initial` argument in CMTK's `registration`. At this
point, everything else runs identically to what we've been doing:

1. Affine registration
2. Warping
3. Use the final transformation to bridge between the two spaces.

The final registration command will look something like this:

```{bash, eval=FALSE }
#!/bin/bash

stem=/mnt/f/Registrations/Claudia/
floating=$stem/hindbrain/images/fish1_correctedDims_01.nrrd
refbrain=$stem/wholeBrainH2B2ZBrain-Bridging/refbrain/ZBrain_Elavl3-H2BRFP-correctedDims.nrrd

# the raw scan of the hindbrain to the hindbrain template
fish2Hind=$stem/hindbrain/Registration/warp/fish3HindTemplate3correctedDims_fish1_correctedDims_01_warp_m0g120c8e1e-1x26r3.list
# Hindbrain template to whole brain template bridging registration
Hind2Whole=$stem/Hind2Full-Bridging/testXform/landmarksWarp.list/
# whole brain template to ZBrain template bridging registration
Whole2Zbrain=$stem/wholeBrainH2B2ZBrain-Bridging/Registration/warp/ZBB_wholeBrainH2B_warp_m0g120c8e1e-1x26r3.list

# [options] --floating floatingImage templateImage x0 [x1 ...]
# the order of the transformations
# x0: last transformation to be applied
# xN: original transformation of the raw data (use the warp output as this includes any intialization steps) 
/opt/local/bin/reformatx \
--outfile $stem/fullRegistrations/reformatted/ZBrain_fish1_correctedDims_01.nrrd \
--floating $floating \
$refbrain \
$Whole2Zbrain \
$Hind2Whole \
$fish2Hind

```


## TODO
Evaluate if these transformations are accurate, or if they distort reality too much. 

See if the registrations as currently available are capable of being inverted. This would be useful for instance if
we wanted to project the anatomical segmentations onto our original or aligned hindbrain data. Also, how does one
project a bigger space onto a smaller space? Do I need to mask it first?

Try this process with ANTs and compare to see if one approach is better. Better can be evaluated on a few levels:
1. Accuracy of transformation
2. Processing time

# Round two
